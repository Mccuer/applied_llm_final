[
    {
        "code": "from   _TFL.pyk           import pyk\n\nfrom   rsclib.HTML_Parse  import tag, Page_Tree\nfrom   rsclib.autosuper   import autosuper\nfrom   spider.common      import Interface, Inet4, Inet6, unroutable\nfrom   spider.common      import WLAN_Config\nfrom   spider.luci        import Version_Mixin\n\nclass Status (Page_Tree, Version_Mixin) :\n    url          = 'cgi-bin/luci/freifunk/status/status'\n    retries      = 2\n    timeout      = 10\n    html_charset = 'utf-8' \n\n    wl_names = dict \\\n        ( ssid    = 'ssid'\n        , _bsiid  = 'bssid'\n        , channel = 'channel'\n        , mode    = 'mode'\n        )\n\n    def parse (self) :\n        root  = self.tree.getroot ()\n        self.wlans  = []\n        self.routes = {}\n        for div in root.findall (\".//%s\" % tag (\"div\")) :\n            id = div.get ('id')\n            if id == 'cbi-wireless' :\n                wlan_div = div\n            elif id == 'cbi-routes' :\n                route_div = div\n            self.try_get_version (div)\n        for d in self.tbl_iter (wlan_div) :\n            for k, newkey in pyk.iteritems (self.wl_names) :\n                if k in d :\n                    d [newkey] = d [k]\n            wl = WLAN_Config (** d)\n            self.wlans.append (wl)\n        for d in self.tbl_iter (route_div) :\n            iface = d.get ('iface')\n            gw    = d.get ('gateway')\n            if iface and gw :\n                self.routes [iface] = gw\n        self.set_version (root)\n    \n\n    def tbl_iter (self, div) :\n        tbl = div.find (\".//%s\" % tag (\"table\"))\n        assert tbl.get ('class') == 'cbi-section-table'\n        d = {}\n        for tr in tbl :\n            if 'cbi-section-table-row' not in tr.get ('class').split () :\n                continue\n            for input in tr.findall (\".//%s\" % tag ('input')) :\n                name = input.get ('id').split ('.') [-1]\n                val  = input.get ('value')\n                d [name] = val\n            if not d :\n                continue\n            yield d\n    \n\n\n\nclass Table_Iter (Page_Tree) :\n\n    def table_iter (self) :\n        root  = self.tree.getroot ()\n        for div in root.findall (\".//%s\" % tag (\"div\")) :\n            if div.get ('id') == 'maincontent' :\n                break\n        tbl = div.find (\".//%s\" % tag (\"table\"))\n        if tbl is None :\n            return\n        for tr in tbl :\n            if tr [0].tag == tag ('th') :\n                continue\n            yield (self.tree.get_text (x) for x in tr)\n    \n\n\n\nclass OLSR_Connections (Table_Iter) :\n    url          = 'cgi-bin/luci/freifunk/olsr/'\n    retries      = 2\n    timeout      = 10\n    html_charset = 'utf-8' \n\n    def parse (self) :\n        self.neighbors = {}\n        for l in self.table_iter () :\n            neighbor, ip, lq, nlq, etx = l\n            lq, nlq, etx = (float (x) for x in (lq, nlq, etx))\n            self.neighbors [neighbor] = [ip, lq, nlq, etx]\n    \n\n\n\nclass OLSR_Routes (Table_Iter) :\n    url          = 'cgi-bin/luci/freifunk/olsr/routes'\n    retries      = 2\n    timeout      = 10\n    html_charset = 'utf-8' \n\n    def parse (self) :\n        self.iface_by_gw = {}\n        for l in self.table_iter () :\n            announced, gw, iface, metric, etx = l\n            if gw in self.iface_by_gw :\n                assert iface == self.iface_by_gw [gw]\n            else :\n                self.iface_by_gw [gw] = iface\n    \n\n\n\nclass OpenWRT (autosuper) :\n\n    def __init__ (self, site, request) :\n        self.site    = site\n        self.request = request\n        if 'interfaces' in self.request or 'ips' in self.request :\n            st    = Status           (site = site)\n            conn  = OLSR_Connections (site = site)\n            route = OLSR_Routes      (site = site)\n            self.version = st.version\n            assert len (st.wlans) <= 1\n            interfaces   = {}\n            ips          = {}\n            count = 0\n            for gw, ifname in pyk.iteritems (route.iface_by_gw) :\n                ip, lq, nlq, etx  = conn.neighbors [gw]\n                i4 = Inet4 (ip, None, None, iface = ifname)\n                ips [i4] = 1\n                is_wlan = True\n                if lq == nlq == etx == 1.0 :\n                    is_wlan = False\n                if ifname in interfaces :\n                    iface = interfaces [ifname]\n                    if not iface.is_wlan and is_wlan :\n                        iface.is_wlan   = True\n                        iface.wlan_info = st.wlans [0]\n                else :\n                    iface = Interface (count, ifname, None)\n                    iface.is_wlan = is_wlan\n                    if is_wlan :\n                        iface.wlan_info = st.wlans [0]\n                    count += 1\n                    interfaces [ifname] = iface\n                if i4 not in iface.inet4 :\n                    iface.append_inet4 (i4)\n            wl_if = None\n            for iface in pyk.itervalues (interfaces) :\n                if iface.is_wlan :\n                    if wl_if :\n                        m = \"Duplicate wlan: %s/%s\" % (iface.name, wl_if.name)\n                        raise ValueError (m)\n                    wl_if = iface\n            \n            n  = 'unknown'\n            i4 = Inet4 (self.request ['ip'], None, None, iface = n)\n            if i4 not in ips :\n                assert n not in interfaces\n                iface = interfaces [n] = Interface (count, n, None)\n                iface.append_inet4 (i4)\n                iface.is_wlan = False\n                if not wl_if and st.wlans :\n                    iface.is_wlan   = True\n                    iface.wlan_info = st.wlans [0]\n                ips [i4] = True\n\n            self.request ['ips']        = ips\n            self.request ['interfaces'] = interfaces\n            self.request ['version']    = st.version\n    \n\n\n"
    },
    {
        "code": "from PIL import Image\nimport cv2\nimport imagehash\nimport math\nimport numpy as np\n\nDIFF_THRES = 20\nLIMIT = 2\nRESIZE = 1000\n\n\ndef calc_hash(img):\n    \n    \n    img = resize(img)\n    return imagehash.whash(Image.fromarray(img))\n\n\ndef compare(hash1, hash2):\n    \n    return hash1 - hash2\n\n\ndef limit(img, std_hash, count):\n    \n    \n    cmp_hash = calc_hash(img)\n\n    \n    diff = compare(std_hash, cmp_hash)\n\n    \n    if diff <= DIFF_THRES:\n        \n        if count >= LIMIT:\n            return 'remove'\n\n    \n    else:\n        \n        return 'update_std'\n\n    \n    return 'continue'\n\n\ndef resize(img):\n    \n    \n    width = np.shape(img)[1]\n    height = np.shape(img)[0]\n\n    \n    if width > RESIZE:\n        \n        scale = RESIZE / width\n        resized_img = cv2.resize(\n            img, (RESIZE, math.floor(height / scale)), cv2.INTER_AREA)\n        \n        return resized_img\n\n    \n    return img\n\n\ndef set_standard(images, filename):\n    \n    return filename, calc_hash(images[filename]), 0\n"
    },
    {
        "code": "from .cli.cli import main\n\n\n\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
        "code": "import time\n\nfrom PyQt5 import QtGui, QtCore\n\nfrom ui.room_item import Ui_Form\nfrom PyQt5.QtWidgets import QWidget\n\nclass Room_Item(QWidget,Ui_Form):\n    def __init__(self,parent=None,room_data=None):\n        super(Room_Item,self).__init__(parent)\n        self.setupUi(self)\n        self.data = room_data\n        self.setRoomInfo()\n\n    def setRoomInfo(self):\n        self.room_name.setText('{}({})'.format(self.data['naturalName'], self.data['roomName']))\n        self.description.setText(\"<a style='color:\n        timeStamp = int(self.data['creationDate']) / 1000\n        timeArray = time.localtime(timeStamp)\n        otherStyleTime = time.strftime(\"%Y-%m-%d\", timeArray)\n        self.create_time.setText(\"<a style='color:\n        members = len(self.data['owners']) + len(self.data['admins']) + len(self.data['members'])\n        memberCounter = \"<a style='color:\n        self.member.setText(memberCounter)"
    },
    {
        "code": "import asyncio\nimport re\nimport sys\nimport traceback\n\nimport toga\nfrom toga import Key\nfrom .keys import toga_to_winforms_key\n\nfrom .libs import Threading, WinForms, shcore, user32, win_version\nfrom .libs.proactor import WinformsProactorEventLoop\nfrom .window import Window\n\n\nclass MainWindow(Window):\n    def winforms_FormClosing(self, sender, event):\n        if not self.interface.app._impl._is_exiting:\n            event.Cancel = not self.interface.app.exit()\n\n\nclass App:\n    _MAIN_WINDOW_CLASS = MainWindow\n\n    def __init__(self, interface):\n        self.interface = interface\n        self.interface._impl = self\n\n        \n        \n        \n        \n        \n        \n        \n        \n        self._is_exiting = False\n\n        self.loop = WinformsProactorEventLoop()\n        asyncio.set_event_loop(self.loop)\n\n    def create(self):\n        self.native = WinForms.Application\n        self.app_context = WinForms.ApplicationContext()\n\n        \n        \n        \n        \n        if win_version.Major >= 6:  \n            \n            \n            if ((win_version.Major == 6 and win_version.Minor == 3) or\n                    (win_version.Major == 10 and win_version.Build < 15063)):\n                shcore.SetProcessDpiAwareness(True)\n            \n            \n            elif win_version.Major == 10 and win_version.Build >= 15063:\n                user32.SetProcessDpiAwarenessContext(-2)\n            \n            else:\n                user32.SetProcessDPIAware()\n\n        self.native.EnableVisualStyles()\n        self.native.SetCompatibleTextRenderingDefault(False)\n\n        self.interface.commands.add(\n            toga.Command(\n                lambda _: self.interface.about(),\n                'About {}'.format(self.interface.name),\n                group=toga.Group.HELP\n            ),\n            toga.Command(None, 'Preferences', group=toga.Group.FILE),\n            \n            toga.Command(\n                lambda _: self.interface.exit(),\n                'Exit ' + self.interface.name,\n                shortcut=Key.MOD_1 + 'q',\n                group=toga.Group.FILE,\n                section=sys.maxsize\n            ),\n            toga.Command(\n                lambda _: self.interface.visit_homepage(),\n                'Visit homepage',\n                enabled=self.interface.home_page is not None,\n                group=toga.Group.HELP\n            )\n        )\n        self._create_app_commands()\n\n        \n        self.interface.startup()\n        self.create_menus()\n        self.interface.icon.bind(self.interface.factory)\n        self.interface.main_window._impl.set_app(self)\n\n    def create_menus(self):\n        self._menu_items = {}\n        self._menu_groups = {}\n\n        toga.Group.FILE.order = 0\n        menubar = WinForms.MenuStrip()\n        submenu = None\n        for cmd in self.interface.commands:\n            if cmd == toga.GROUP_BREAK:\n                submenu = None\n            elif cmd == toga.SECTION_BREAK:\n                submenu.DropDownItems.Add('-')\n            else:\n                submenu = self._submenu(cmd.group, menubar)\n\n                item = WinForms.ToolStripMenuItem(cmd.label)\n\n                if cmd.action:\n                    item.Click += cmd._impl.as_handler()\n                item.Enabled = cmd.enabled\n\n                if cmd.shortcut is not None:\n                    shortcut_keys = toga_to_winforms_key(cmd.shortcut)\n                    item.ShortcutKeys = shortcut_keys\n                    item.ShowShortcutKeys = True\n\n                cmd._impl.native.append(item)\n\n                self._menu_items[item] = cmd\n                submenu.DropDownItems.Add(item)\n\n        self.interface.main_window._impl.native.Controls.Add(menubar)\n        self.interface.main_window._impl.native.MainMenuStrip = menubar\n        self.interface.main_window.content.refresh()\n\n    def _submenu(self, group, menubar):\n        try:\n            return self._menu_groups[group]\n        except KeyError:\n            if group is None:\n                submenu = menubar\n            else:\n                parent_menu = self._submenu(group.parent, menubar)\n\n                submenu = WinForms.ToolStripMenuItem(group.label)\n\n                \n                if group.parent is None:\n                    parent_menu.Items.Add(submenu)\n                else:\n                    parent_menu.DropDownItems.Add(submenu)\n\n            self._menu_groups[group] = submenu\n        return submenu\n\n    def _create_app_commands(self):\n        \n        pass\n\n    def open_document(self, fileURL):\n        \n        print(\"STUB: If you want to handle opening documents, implement App.open_document(fileURL)\")\n\n    def winforms_thread_exception(self, sender, winforms_exc):\n        \n        \n        \n        \n        \n        \n        \n        \n        print(\"Traceback (most recent call last):\")\n        py_exc = winforms_exc.get_Exception()\n        full_stack_trace = py_exc.StackTrace\n        regex = re.compile(\n            r\"^\\[(?:'(.*?)', )*(?:'(.*?)')\\]   (?:.*?) Python\\.Runtime\",\n            re.DOTALL | re.UNICODE\n        )\n\n        stacktrace_relevant_lines = regex.findall(full_stack_trace)\n        if len(stacktrace_relevant_lines) == 0:\n            self.print_stack_trace(full_stack_trace)\n        else:\n            for lines in stacktrace_relevant_lines:\n                for line in lines:\n                    self.print_stack_trace(line)\n        print(py_exc.Message)\n\n    @classmethod\n    def print_stack_trace(cls, stack_trace_line):\n        for level in stack_trace_line.split(\"', '\"):\n            for line in level.split(\"\\\\n\"):\n                if line:\n                    print(line)\n\n    def run_app(self):\n        try:\n            self.create()\n\n            self.native.ThreadException += self.winforms_thread_exception\n\n            self.loop.run_forever(self.app_context)\n        except:  \n            traceback.print_exc()\n\n    def main_loop(self):\n        thread = Threading.Thread(Threading.ThreadStart(self.run_app))\n        thread.SetApartmentState(Threading.ApartmentState.STA)\n        thread.Start()\n        thread.Join()\n\n    def show_about_dialog(self):\n        message_parts = []\n        if self.interface.name is not None:\n            if self.interface.version is not None:\n                message_parts.append(\n                    \"{name} v{version}\".format(\n                        name=self.interface.name,\n                        version=self.interface.version,\n                    )\n                )\n            else:\n                message_parts.append(\n                    \"{name}\".format(name=self.interface.name)\n                )\n        elif self.interface.version is not None:\n            message_parts.append(\n                \"v{version}\".format(version=self.interface.version)\n            )\n\n        if self.interface.author is not None:\n            message_parts.append(\n                \"Author: {author}\".format(author=self.interface.author)\n            )\n        if self.interface.description is not None:\n            message_parts.append(\n                \"\\n{description}\".format(\n                    description=self.interface.description\n                )\n            )\n        self.interface.main_window.info_dialog(\n            'About {}'.format(self.interface.name), \"\\n\".join(message_parts)\n        )\n\n    def exit(self):\n        self._is_exiting = True\n        self.native.Exit()\n\n    def set_main_window(self, window):\n        self.app_context.MainForm = window._impl.native\n\n    def set_on_exit(self, value):\n        pass\n\n    def current_window(self):\n        self.interface.factory.not_implemented('App.current_window()')\n\n    def enter_full_screen(self, windows):\n        self.interface.factory.not_implemented('App.enter_full_screen()')\n\n    def exit_full_screen(self, windows):\n        self.interface.factory.not_implemented('App.exit_full_screen()')\n\n    def set_cursor(self, value):\n        self.interface.factory.not_implemented('App.set_cursor()')\n\n    def show_cursor(self):\n        self.interface.factory.not_implemented('App.show_cursor()')\n\n    def hide_cursor(self):\n        self.interface.factory.not_implemented('App.hide_cursor()')\n\n    def add_background_task(self, handler):\n        self.loop.call_soon(handler, self)\n\n\nclass DocumentApp(App):\n    def _create_app_commands(self):\n        self.interface.commands.add(\n            toga.Command(\n                lambda w: self.open_file,\n                label='Open...',\n                shortcut=Key.MOD_1 + 'o',\n                group=toga.Group.FILE,\n                section=0\n            ),\n        )\n\n    def open_document(self, fileURL):\n        \n        self.interface.factory.not_implemented('DocumentApp.open_document()')\n"
    },
    {
        "code": "__version__ = \"0.4.0\"\n\n\ndef classFactory(iface):  \n    \n    \n    from .SimplePhotogrammetryRoutePlanner import SimplePhotogrammetryRoutePlanner\n    return SimplePhotogrammetryRoutePlanner(iface)\n"
    },
    {
        "code": "from sklearn.feature_selection import VarianceThreshold\nimport numpy as np\n\nnp.random.seed(1)\nX = np.random.randn(100, 10)\nX = np.hstack([X, np.zeros([100, 5])])\n\n\n\ndef featureSelection_variance(X, thrd):\n    sel = VarianceThreshold(threshold=thrd)\n    X_selected = sel.fit_transform(X)\n    mask = sel.get_support()\n    return X_selected, mask\n\n\nX = [[0, 2, 0, 3], [0, 1, 4, 3], [0, 1, 1, 3]]\nselector = VarianceThreshold()\nselector.fit_transform(X)\nselector.variances_\n"
    },
    {
        "code": "from my_multi_main3 import main\nimport numpy as np\nimport argparse\nimport time\n\nparser = argparse.ArgumentParser(description='PyTorch MNIST Example')\nparser.add_argument('--batch-size', type=int, default=64, metavar='N',\n                    help='input batch size for training (default: 64)')\nparser.add_argument('--test-batch-size', type=int, default=1000, metavar='N',\n                    help='input batch size for testing (default: 1000)')\nparser.add_argument('--epochs', type=int, default=10, metavar='N',\n                    help='number of epochs to train (default: 10)')\nparser.add_argument('--lr', type=float, default=0.01, metavar='LR',\n                    help='learning rate (default: 0.01)')\nparser.add_argument('--momentum', type=float, default=0.5, metavar='M',\n                    help='SGD momentum (default: 0.5)')\nparser.add_argument('--no-cuda', action='store_true', default=False,\n                    help='disables CUDA training')\nparser.add_argument('--seed', type=int, default=1, metavar='S',\n                    help='random seed (default: 1)')\nparser.add_argument('--log-interval', type=int, default=10, metavar='N',\n                    help='how many batches to wait before logging training status')\nparser.add_argument('--save-model', action='store_true', default=False,\n                    help='For Saving the current Model')\nparser.add_argument('--norm-flag', type=bool, default=False,\n                    help='Triggering the Layer Normalization flag for attention scores')\nparser.add_argument('--gamma', type=float, default=None,\n                    help='Controlling the sparisty of gfusedmax/sparsemax, the smaller, the more sparse')\nparser.add_argument('--lam', type=float, default=1.0,\n                    help='Lambda: Controlling the smoothness of gfusedmax, the larger, the smoother')\nparser.add_argument('--max-type', type=str, default='softmax',choices=['softmax','sparsemax','gfusedmax'],\n                    help='mapping function in attention')\nparser.add_argument('--optim-type', type=str, default='SGD',choices=['SGD','Adam'],\n                    help='mapping function in attention')\nparser.add_argument('--head-cnt', type=int, default=2, metavar='S', choices=[1,2,4,5,10],\n                    help='Number of heads for attention (default: 1)')\n\nargs = parser.parse_args()\n\nhyperparameter_choices = {\n    'lr':list(10**np.arange(-4,-1,0.5)),\n    'norm_flag': [True,False],\n    'gamma':list(10**np.arange(-1,3,0.5))+[None,],\n    'lam':list(10**np.arange(-2,2,0.5)),\n    'max_type':['softmax','sparsemax','gfusedmax'],\n    \n    'optim_type':['SGD','Adam'],\n    'head_cnt':[1,2,4,5,10,20]\n}\n\nparam_num = 25\nrecord = np.zeros([param_num,len(hyperparameter_choices)+1])\nrecord_name = 'record3_multi_%s.csv'%time.strftime('%Y-%m-%d_%H-%M-%S',time.localtime())\nfor n in range(param_num):\n    for param_index,(k,v) in enumerate(hyperparameter_choices.items()):\n        print(param_index,k)\n        value_index = np.random.choice(len(v))\n        if isinstance(v[value_index],str) or isinstance(v[value_index],bool) or v[value_index] is None:\n            record[n,param_index] = value_index\n        else:\n            record[n,param_index] = v[value_index]\n        setattr(args,k,v[value_index])\n    record[n,-1] = main(args)\n    np.savetxt(record_name, record, delimiter=',')\n\n\n\n"
    },
    {
        "code": "from __future__ import print_function, absolute_import\n\nimport h5py\n\nfrom spiker import log\n\nlogger = log.get_logger(\"data-hdf5\", log.DEBUG)\n\n\ndef init_hdf5(file_path, mode=\"w\", cam_type=\"davis\"):\n    \n    if mode == \"w\":\n        dataset = h5py.File(file_path, mode=mode)\n        dataset.create_group(\"dvs\")\n        dataset.create_group(\"extra\")\n        if cam_type == \"davis\":\n            dataset.create_group(\"aps\")\n            dataset.create_group(\"imu\")\n    elif mode == \"r\":\n        dataset = h5py.File(file_path, mode=mode)\n\n    return dataset\n"
    },
    {
        "code": "import flatbuffers\n\nclass FloatingPoint(object):\n    __slots__ = ['_tab']\n\n    @classmethod\n    def GetRootAsFloatingPoint(cls, buf, offset):\n        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)\n        x = FloatingPoint()\n        x.Init(buf, n + offset)\n        return x\n\n    \n    def Init(self, buf, pos):\n        self._tab = flatbuffers.table.Table(buf, pos)\n\n    \n    def Precision(self):\n        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))\n        if o != 0:\n            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)\n        return 0\n\ndef FloatingPointStart(builder): builder.StartObject(1)\ndef FloatingPointAddPrecision(builder, precision): builder.PrependInt16Slot(0, precision, 0)\ndef FloatingPointEnd(builder): return builder.EndObject()\n"
    }
]