[
    {
        "code": "from   _TFL.pyk           import pyk\n\nfrom   rsclib.HTML_Parse  import tag, Page_Tree\nfrom   rsclib.autosuper   import autosuper\nfrom   spider.common      import Interface, Inet4, Inet6, unroutable\nfrom   spider.common      import WLAN_Config\nfrom   spider.luci        import Version_Mixin\n\nclass Status (Page_Tree, Version_Mixin) :\n    url          = 'cgi-bin/luci/freifunk/status/status'\n    retries      = 2\n    timeout      = 10\n    html_charset = 'utf-8' \n\n    wl_names = dict \\\n        ( ssid    = 'ssid'\n        , _bsiid  = 'bssid'\n        , channel = 'channel'\n        , mode    = 'mode'\n        )\n\n    def parse (self) :\n        root  = self.tree.getroot ()\n        self.wlans  = []\n        self.routes = {}\n        for div in root.findall (\".//%s\" % tag (\"div\")) :\n            id = div.get ('id')\n            if id == 'cbi-wireless' :\n                wlan_div = div\n            elif id == 'cbi-routes' :\n                route_div = div\n            self.try_get_version (div)\n        for d in self.tbl_iter (wlan_div) :\n            for k, newkey in pyk.iteritems (self.wl_names) :\n                if k in d :\n                    d [newkey] = d [k]\n            wl = WLAN_Config (** d)\n            self.wlans.append (wl)\n        for d in self.tbl_iter (route_div) :\n            iface = d.get ('iface')\n            gw    = d.get ('gateway')\n            if iface and gw :\n                self.routes [iface] = gw\n        self.set_version (root)\n    \n\n    def tbl_iter (self, div) :\n        tbl = div.find (\".//%s\" % tag (\"table\"))\n        assert tbl.get ('class') == 'cbi-section-table'\n        d = {}\n        for tr in tbl :\n            if 'cbi-section-table-row' not in tr.get ('class').split () :\n                continue\n            for input in tr.findall (\".//%s\" % tag ('input')) :\n                name = input.get ('id').split ('.') [-1]\n                val  = input.get ('value')\n                d [name] = val\n            if not d :\n                continue\n            yield d\n    \n\n\n\nclass Table_Iter (Page_Tree) :\n\n    def table_iter (self) :\n        root  = self.tree.getroot ()\n        for div in root.findall (\".//%s\" % tag (\"div\")) :\n            if div.get ('id') == 'maincontent' :\n                break\n        tbl = div.find (\".//%s\" % tag (\"table\"))\n        if tbl is None :\n            return\n        for tr in tbl :\n            if tr [0].tag == tag ('th') :\n                continue\n            yield (self.tree.get_text (x) for x in tr)\n    \n\n\n\nclass OLSR_Connections (Table_Iter) :\n    url          = 'cgi-bin/luci/freifunk/olsr/'\n    retries      = 2\n    timeout      = 10\n    html_charset = 'utf-8' \n\n    def parse (self) :\n        self.neighbors = {}\n        for l in self.table_iter () :\n            neighbor, ip, lq, nlq, etx = l\n            lq, nlq, etx = (float (x) for x in (lq, nlq, etx))\n            self.neighbors [neighbor] = [ip, lq, nlq, etx]\n    \n\n\n\nclass OLSR_Routes (Table_Iter) :\n    url          = 'cgi-bin/luci/freifunk/olsr/routes'\n    retries      = 2\n    timeout      = 10\n    html_charset = 'utf-8' \n\n    def parse (self) :\n        self.iface_by_gw = {}\n        for l in self.table_iter () :\n            announced, gw, iface, metric, etx = l\n            if gw in self.iface_by_gw :\n                assert iface == self.iface_by_gw [gw]\n            else :\n                self.iface_by_gw [gw] = iface\n    \n\n\n\nclass OpenWRT (autosuper) :\n\n    def __init__ (self, site, request) :\n        self.site    = site\n        self.request = request\n        if 'interfaces' in self.request or 'ips' in self.request :\n            st    = Status           (site = site)\n            conn  = OLSR_Connections (site = site)\n            route = OLSR_Routes      (site = site)\n            self.version = st.version\n            assert len (st.wlans) <= 1\n            interfaces   = {}\n            ips          = {}\n            count = 0\n            for gw, ifname in pyk.iteritems (route.iface_by_gw) :\n                ip, lq, nlq, etx  = conn.neighbors [gw]\n                i4 = Inet4 (ip, None, None, iface = ifname)\n                ips [i4] = 1\n                is_wlan = True\n                if lq == nlq == etx == 1.0 :\n                    is_wlan = False\n                if ifname in interfaces :\n                    iface = interfaces [ifname]\n                    if not iface.is_wlan and is_wlan :\n                        iface.is_wlan   = True\n                        iface.wlan_info = st.wlans [0]\n                else :\n                    iface = Interface (count, ifname, None)\n                    iface.is_wlan = is_wlan\n                    if is_wlan :\n                        iface.wlan_info = st.wlans [0]\n                    count += 1\n                    interfaces [ifname] = iface\n                if i4 not in iface.inet4 :\n                    iface.append_inet4 (i4)\n            wl_if = None\n            for iface in pyk.itervalues (interfaces) :\n                if iface.is_wlan :\n                    if wl_if :\n                        m = \"Duplicate wlan: %s/%s\" % (iface.name, wl_if.name)\n                        raise ValueError (m)\n                    wl_if = iface\n            \n            n  = 'unknown'\n            i4 = Inet4 (self.request ['ip'], None, None, iface = n)\n            if i4 not in ips :\n                assert n not in interfaces\n                iface = interfaces [n] = Interface (count, n, None)\n                iface.append_inet4 (i4)\n                iface.is_wlan = False\n                if not wl_if and st.wlans :\n                    iface.is_wlan   = True\n                    iface.wlan_info = st.wlans [0]\n                ips [i4] = True\n\n            self.request ['ips']        = ips\n            self.request ['interfaces'] = interfaces\n            self.request ['version']    = st.version\n    \n\n\n",
        "summary": "This Python code defines several classes to parse and process data from web pages related to a Freifunk network, which is a decentralized mesh networking system. The main functionalities include:\n\n1. **Status Class**: Parses the status page of a Freifunk node. It extracts information about wireless networks (WLANs) and routing tables. It uses `Page_Tree` for parsing HTML and `Version_Mixin` to handle versioning.\n\n2. **Table_Iter Class**: A base class for iterating over tables in HTML pages. It finds the main content div and iterates over table rows, extracting text data from each row.\n\n3. **OLSR_Connections Class**: Parses the OLSR (Optimized Link State Routing) connections page. It extracts information about network neighbors and their IP addresses along with link quality metrics.\n\n4. **OLSR_Routes Class**: Parses the OLSR routes page. It extracts routing table information, mapping gateways to interfaces.\n\n5. **OpenWRT Class**: This class integrates all the above functionalities. It initializes instances of `Status`, `OLSR_Connections`, and `OLSR_Routes` to gather data from different pages. It then processes this data to create a structured representation of network interfaces, their IP addresses, and wireless information.\n\nThe code uses various utilities like `pyk` for dictionary operations, `rsclib.HTML_Parse` for HTML parsing, and custom classes like `Interface`, `Inet4`, and `WLAN_Config` to represent different aspects of the network configuration. The `autosuper` decorator is used to simplify class inheritance.\n\nOverall, this code provides a comprehensive solution for extracting and processing network data from Freifunk nodes, which can be useful for monitoring and management purposes."
    },
    {
        "code": "from PIL import Image\nimport cv2\nimport imagehash\nimport math\nimport numpy as np\n\nDIFF_THRES = 20\nLIMIT = 2\nRESIZE = 1000\n\n\ndef calc_hash(img):\n    \n    \n    img = resize(img)\n    return imagehash.whash(Image.fromarray(img))\n\n\ndef compare(hash1, hash2):\n    \n    return hash1 - hash2\n\n\ndef limit(img, std_hash, count):\n    \n    \n    cmp_hash = calc_hash(img)\n\n    \n    diff = compare(std_hash, cmp_hash)\n\n    \n    if diff <= DIFF_THRES:\n        \n        if count >= LIMIT:\n            return 'remove'\n\n    \n    else:\n        \n        return 'update_std'\n\n    \n    return 'continue'\n\n\ndef resize(img):\n    \n    \n    width = np.shape(img)[1]\n    height = np.shape(img)[0]\n\n    \n    if width > RESIZE:\n        \n        scale = RESIZE / width\n        resized_img = cv2.resize(\n            img, (RESIZE, math.floor(height / scale)), cv2.INTER_AREA)\n        \n        return resized_img\n\n    \n    return img\n\n\ndef set_standard(images, filename):\n    \n    return filename, calc_hash(images[filename]), 0\n",
        "summary": "This Python code is designed to process images and determine whether they should be updated or removed based on their similarity to a standard image. Here's a summary of the key components:\n\n1. **Imports**: The code imports necessary libraries including PIL for image processing, cv2 for computer vision tasks, imagehash for hashing images, math for mathematical operations, and numpy for numerical computations.\n\n2. **Constants**:\n   - `DIFF_THRES`: A threshold value (20) used to compare the difference between hashes.\n   - `LIMIT`: A limit on how many times an image can be updated before it is removed (2).\n   - `RESIZE`: The maximum width of images after resizing (1000 pixels).\n\n3. **Functions**:\n   - **`calc_hash(img)`**: Resizes the image and calculates its hash using the Wavelet Hashing method.\n   - **`compare(hash1, hash2)`**: Compares two hashes by subtracting one from the other.\n   - **`limit(img, std_hash, count)`**: Determines whether to update the standard image, remove it, or continue processing based on the difference between the current image's hash and the standard hash. It also checks if the image has been updated too many times.\n   - **`resize(img)`**: Resizes an image to a maximum width of 1000 pixels while maintaining the aspect ratio.\n   - **`set_standard(images, filename)`**: Sets up the standard image by calculating its hash and initializing a count.\n\n4. **Usage**:\n   - The code is intended to be used in a larger system where images are processed and compared against a standard image. It helps in managing image versions and deciding whether to keep or remove them based on their similarity.\n\nThis code provides a basic framework for image version control and can be extended with additional functionality such as handling multiple images, saving the state of images, and integrating with other systems for image management."
    },
    {
        "code": "from .cli.cli import main\n\n\n\n\n\nif __name__ == '__main__':\n    main()\n",
        "summary": "This Python script is designed to run a command-line interface (CLI) application. Here's a breakdown of what it does:\n\n1. **Import Statement**:\n   ```python\n   from .cli.cli import main\n   ```\n   This line imports the `main` function from the `cli.py` module located in the `cli` subdirectory relative to the current script.\n\n2. **Main Guard**:\n   ```python\n   if __name__ == '__main__':\n       main()\n   ```\n   This is a common Python idiom known as the \"main guard\" or \"entry point\". It checks whether the script is being run directly (i.e., not imported as a module in another script). If it is being run directly, it calls the `main` function.\n\n### Summary\n- The script imports a `main` function from a subdirectory.\n- It includes a guard to ensure that the `main` function is only called when the script is executed directly, not when imported as a module."
    },
    {
        "code": "import time\n\nfrom PyQt5 import QtGui, QtCore\n\nfrom ui.room_item import Ui_Form\nfrom PyQt5.QtWidgets import QWidget\n\nclass Room_Item(QWidget,Ui_Form):\n    def __init__(self,parent=None,room_data=None):\n        super(Room_Item,self).__init__(parent)\n        self.setupUi(self)\n        self.data = room_data\n        self.setRoomInfo()\n\n    def setRoomInfo(self):\n        self.room_name.setText('{}({})'.format(self.data['naturalName'], self.data['roomName']))\n        self.description.setText(\"<a style='color:\n        timeStamp = int(self.data['creationDate']) / 1000\n        timeArray = time.localtime(timeStamp)\n        otherStyleTime = time.strftime(\"%Y-%m-%d\", timeArray)\n        self.create_time.setText(\"<a style='color:\n        members = len(self.data['owners']) + len(self.data['admins']) + len(self.data['members'])\n        memberCounter = \"<a style='color:\n        self.member.setText(memberCounter)",
        "summary": "This Python code defines a class `Room_Item` that inherits from both `QWidget` and `Ui_Form`. The class is designed to display information about a room in a graphical user interface (GUI). Here's a summary of the key components:\n\n1. **Imports**:\n   - The code imports necessary modules, including `time`, `PyQt5.QtGui`, `PyQt5.QtCore`, and custom UI elements from `ui.room_item`.\n\n2. **Class Definition**:\n   - `Room_Item` is a subclass of `QWidget` and `Ui_Form`. This allows it to use both the widget functionality and the UI layout defined in `Ui_Form`.\n\n3. **Constructor (`__init__`)**:\n   - The constructor initializes the `Room_Item` object.\n   - It calls the superclass constructors using `super(Room_Item, self).__init__(parent)`.\n   - It sets up the user interface by calling `self.setupUi(self)`.\n   - It stores the room data passed as an argument and calls `self.setRoomInfo()` to populate the UI with this data.\n\n4. **Method (`setRoomInfo`)**:\n   - This method updates the UI elements based on the room data.\n   - It sets the text of a label (`room_name`) to display both the natural name and the room name of the room.\n   - It converts a timestamp (presumably in milliseconds) from the room data into a human-readable date format and displays it.\n   - It calculates the total number of members (owners, admins, and regular members) and updates another label (`member`) with this count.\n\nThe code is structured to be used within a PyQt5 application, where `Room_Item` would typically be instantiated and added to a layout in a main window or dialog."
    },
    {
        "code": "import asyncio\nimport re\nimport sys\nimport traceback\n\nimport toga\nfrom toga import Key\nfrom .keys import toga_to_winforms_key\n\nfrom .libs import Threading, WinForms, shcore, user32, win_version\nfrom .libs.proactor import WinformsProactorEventLoop\nfrom .window import Window\n\n\nclass MainWindow(Window):\n    def winforms_FormClosing(self, sender, event):\n        if not self.interface.app._impl._is_exiting:\n            event.Cancel = not self.interface.app.exit()\n\n\nclass App:\n    _MAIN_WINDOW_CLASS = MainWindow\n\n    def __init__(self, interface):\n        self.interface = interface\n        self.interface._impl = self\n\n        \n        \n        \n        \n        \n        \n        \n        \n        self._is_exiting = False\n\n        self.loop = WinformsProactorEventLoop()\n        asyncio.set_event_loop(self.loop)\n\n    def create(self):\n        self.native = WinForms.Application\n        self.app_context = WinForms.ApplicationContext()\n\n        \n        \n        \n        \n        if win_version.Major >= 6:  \n            \n            \n            if ((win_version.Major == 6 and win_version.Minor == 3) or\n                    (win_version.Major == 10 and win_version.Build < 15063)):\n                shcore.SetProcessDpiAwareness(True)\n            \n            \n            elif win_version.Major == 10 and win_version.Build >= 15063:\n                user32.SetProcessDpiAwarenessContext(-2)\n            \n            else:\n                user32.SetProcessDPIAware()\n\n        self.native.EnableVisualStyles()\n        self.native.SetCompatibleTextRenderingDefault(False)\n\n        self.interface.commands.add(\n            toga.Command(\n                lambda _: self.interface.about(),\n                'About {}'.format(self.interface.name),\n                group=toga.Group.HELP\n            ),\n            toga.Command(None, 'Preferences', group=toga.Group.FILE),\n            \n            toga.Command(\n                lambda _: self.interface.exit(),\n                'Exit ' + self.interface.name,\n                shortcut=Key.MOD_1 + 'q',\n                group=toga.Group.FILE,\n                section=sys.maxsize\n            ),\n            toga.Command(\n                lambda _: self.interface.visit_homepage(),\n                'Visit homepage',\n                enabled=self.interface.home_page is not None,\n                group=toga.Group.HELP\n            )\n        )\n        self._create_app_commands()\n\n        \n        self.interface.startup()\n        self.create_menus()\n        self.interface.icon.bind(self.interface.factory)\n        self.interface.main_window._impl.set_app(self)\n\n    def create_menus(self):\n        self._menu_items = {}\n        self._menu_groups = {}\n\n        toga.Group.FILE.order = 0\n        menubar = WinForms.MenuStrip()\n        submenu = None\n        for cmd in self.interface.commands:\n            if cmd == toga.GROUP_BREAK:\n                submenu = None\n            elif cmd == toga.SECTION_BREAK:\n                submenu.DropDownItems.Add('-')\n            else:\n                submenu = self._submenu(cmd.group, menubar)\n\n                item = WinForms.ToolStripMenuItem(cmd.label)\n\n                if cmd.action:\n                    item.Click += cmd._impl.as_handler()\n                item.Enabled = cmd.enabled\n\n                if cmd.shortcut is not None:\n                    shortcut_keys = toga_to_winforms_key(cmd.shortcut)\n                    item.ShortcutKeys = shortcut_keys\n                    item.ShowShortcutKeys = True\n\n                cmd._impl.native.append(item)\n\n                self._menu_items[item] = cmd\n                submenu.DropDownItems.Add(item)\n\n        self.interface.main_window._impl.native.Controls.Add(menubar)\n        self.interface.main_window._impl.native.MainMenuStrip = menubar\n        self.interface.main_window.content.refresh()\n\n    def _submenu(self, group, menubar):\n        try:\n            return self._menu_groups[group]\n        except KeyError:\n            if group is None:\n                submenu = menubar\n            else:\n                parent_menu = self._submenu(group.parent, menubar)\n\n                submenu = WinForms.ToolStripMenuItem(group.label)\n\n                \n                if group.parent is None:\n                    parent_menu.Items.Add(submenu)\n                else:\n                    parent_menu.DropDownItems.Add(submenu)\n\n            self._menu_groups[group] = submenu\n        return submenu\n\n    def _create_app_commands(self):\n        \n        pass\n\n    def open_document(self, fileURL):\n        \n        print(\"STUB: If you want to handle opening documents, implement App.open_document(fileURL)\")\n\n    def winforms_thread_exception(self, sender, winforms_exc):\n        \n        \n        \n        \n        \n        \n        \n        \n        print(\"Traceback (most recent call last):\")\n        py_exc = winforms_exc.get_Exception()\n        full_stack_trace = py_exc.StackTrace\n        regex = re.compile(\n            r\"^\\[(?:'(.*?)', )*(?:'(.*?)')\\]   (?:.*?) Python\\.Runtime\",\n            re.DOTALL | re.UNICODE\n        )\n\n        stacktrace_relevant_lines = regex.findall(full_stack_trace)\n        if len(stacktrace_relevant_lines) == 0:\n            self.print_stack_trace(full_stack_trace)\n        else:\n            for lines in stacktrace_relevant_lines:\n                for line in lines:\n                    self.print_stack_trace(line)\n        print(py_exc.Message)\n\n    @classmethod\n    def print_stack_trace(cls, stack_trace_line):\n        for level in stack_trace_line.split(\"', '\"):\n            for line in level.split(\"\\\\n\"):\n                if line:\n                    print(line)\n\n    def run_app(self):\n        try:\n            self.create()\n\n            self.native.ThreadException += self.winforms_thread_exception\n\n            self.loop.run_forever(self.app_context)\n        except:  \n            traceback.print_exc()\n\n    def main_loop(self):\n        thread = Threading.Thread(Threading.ThreadStart(self.run_app))\n        thread.SetApartmentState(Threading.ApartmentState.STA)\n        thread.Start()\n        thread.Join()\n\n    def show_about_dialog(self):\n        message_parts = []\n        if self.interface.name is not None:\n            if self.interface.version is not None:\n                message_parts.append(\n                    \"{name} v{version}\".format(\n                        name=self.interface.name,\n                        version=self.interface.version,\n                    )\n                )\n            else:\n                message_parts.append(\n                    \"{name}\".format(name=self.interface.name)\n                )\n        elif self.interface.version is not None:\n            message_parts.append(\n                \"v{version}\".format(version=self.interface.version)\n            )\n\n        if self.interface.author is not None:\n            message_parts.append(\n                \"Author: {author}\".format(author=self.interface.author)\n            )\n        if self.interface.description is not None:\n            message_parts.append(\n                \"\\n{description}\".format(\n                    description=self.interface.description\n                )\n            )\n        self.interface.main_window.info_dialog(\n            'About {}'.format(self.interface.name), \"\\n\".join(message_parts)\n        )\n\n    def exit(self):\n        self._is_exiting = True\n        self.native.Exit()\n\n    def set_main_window(self, window):\n        self.app_context.MainForm = window._impl.native\n\n    def set_on_exit(self, value):\n        pass\n\n    def current_window(self):\n        self.interface.factory.not_implemented('App.current_window()')\n\n    def enter_full_screen(self, windows):\n        self.interface.factory.not_implemented('App.enter_full_screen()')\n\n    def exit_full_screen(self, windows):\n        self.interface.factory.not_implemented('App.exit_full_screen()')\n\n    def set_cursor(self, value):\n        self.interface.factory.not_implemented('App.set_cursor()')\n\n    def show_cursor(self):\n        self.interface.factory.not_implemented('App.show_cursor()')\n\n    def hide_cursor(self):\n        self.interface.factory.not_implemented('App.hide_cursor()')\n\n    def add_background_task(self, handler):\n        self.loop.call_soon(handler, self)\n\n\nclass DocumentApp(App):\n    def _create_app_commands(self):\n        self.interface.commands.add(\n            toga.Command(\n                lambda w: self.open_file,\n                label='Open...',\n                shortcut=Key.MOD_1 + 'o',\n                group=toga.Group.FILE,\n                section=0\n            ),\n        )\n\n    def open_document(self, fileURL):\n        \n        self.interface.factory.not_implemented('DocumentApp.open_document()')\n",
        "summary": "This Python code defines a class `App` that represents the main application logic for a Toga-based GUI application running on Windows using WinForms. The class includes methods to create and manage the application window, handle commands, create menus, and manage the event loop.\n\nKey functionalities include:\n- Initializing the application with an interface.\n- Creating the main window and setting up the event loop.\n- Handling menu creation and command execution.\n- Managing document opening.\n- Running the application in a separate thread to avoid blocking the UI.\n- Providing methods for showing about dialogs, exiting the application, and managing cursor visibility.\n\nThe `DocumentApp` class extends `App` and adds specific functionality for handling documents, including an \"Open...\" menu item."
    },
    {
        "code": "__version__ = \"0.4.0\"\n\n\ndef classFactory(iface):  \n    \n    \n    from .SimplePhotogrammetryRoutePlanner import SimplePhotogrammetryRoutePlanner\n    return SimplePhotogrammetryRoutePlanner(iface)\n",
        "summary": "This Python code defines a module with a version number and a function to create an instance of a specific class. Here's a summary:\n\n1. **Version Information**:\n   - The `__version__` variable is set to `\"0.4.0\"`, indicating the version of this module.\n\n2. **Class Factory Function**:\n   - The `classFactory` function takes one parameter, `iface`.\n   - Inside the function, it imports a class named `SimplePhotogrammetryRoutePlanner` from a relative module (`from .SimplePhotogrammetryRoutePlanner import SimplePhotogrammetryRoutePlanner`).\n   - It then returns an instance of `SimplePhotogrammetryRoutePlanner`, passing the `iface` parameter to its constructor.\n\n### Purpose\nThis code is likely part of a larger system where different route planning algorithms or tools are dynamically loaded and instantiated based on some configuration or interface. The `classFactory` function serves as a factory method to create instances of the `SimplePhotogrammetryRoutePlanner` class, which presumably implements specific functionality for photogrammetry-based route planning.\n\n### Usage\nTo use this code:\n1. Ensure that the relative module (`SimplePhotogrammetryRoutePlanner.py`) is in the same directory or correctly referenced.\n2. Call the `classFactory` function with an appropriate `iface` parameter to create an instance of `SimplePhotogrammetryRoutePlanner`.\n\nExample usage:\n```python\nfrom . import classFactory\n\n# Assuming 'iface' is already defined and suitable for the route planner\nroute_planner = classFactory(iface)\n```\n\nThis would create an instance of `SimplePhotogrammetryRoutePlanner` with the provided `iface`."
    },
    {
        "code": "from sklearn.feature_selection import VarianceThreshold\nimport numpy as np\n\nnp.random.seed(1)\nX = np.random.randn(100, 10)\nX = np.hstack([X, np.zeros([100, 5])])\n\n\n\ndef featureSelection_variance(X, thrd):\n    sel = VarianceThreshold(threshold=thrd)\n    X_selected = sel.fit_transform(X)\n    mask = sel.get_support()\n    return X_selected, mask\n\n\nX = [[0, 2, 0, 3], [0, 1, 4, 3], [0, 1, 1, 3]]\nselector = VarianceThreshold()\nselector.fit_transform(X)\nselector.variances_\n",
        "summary": "The provided Python code demonstrates how to use the `VarianceThreshold` class from the `sklearn.feature_selection` module for feature selection based on variance. Here's a summary of the code:\n\n1. **Importing Libraries**:\n   - The code imports `VarianceThreshold` from `sklearn.feature_selection` and `numpy` as `np`.\n\n2. **Setting Random Seed and Creating Data**:\n   - A random seed is set to 1 for reproducibility.\n   - A matrix `X` of shape (100, 10) is created with normally distributed random numbers.\n   - Additional columns of zeros are appended to `X`, making it a total of 15 columns.\n\n3. **Defining the Feature Selection Function**:\n   - The function `featureSelection_variance` takes two parameters: `X` (the data matrix) and `thrd` (the threshold for variance).\n   - It creates an instance of `VarianceThreshold` with the specified threshold.\n   - The function fits the selector to `X` and transforms it, selecting features based on their variance being greater than or equal to the threshold.\n   - It returns the transformed data matrix `X_selected` and a boolean mask indicating which features were selected.\n\n4. **Example Usage of Feature Selection Function**:\n   - A small example dataset `X` is defined with three rows and four columns.\n   - An instance of `VarianceThreshold` is created without specifying a threshold, so it uses the default threshold (0).\n   - The function `fit_transform` is called on this selector with the example data, which selects features based on their variance.\n   - The variances of all features in the dataset are printed.\n\nIn summary, the code provides a basic implementation of feature selection using variance as a criterion. It includes both a general-purpose function for applying variance thresholding to any dataset and an example demonstrating its use with a small dataset."
    },
    {
        "code": "from my_multi_main3 import main\nimport numpy as np\nimport argparse\nimport time\n\nparser = argparse.ArgumentParser(description='PyTorch MNIST Example')\nparser.add_argument('--batch-size', type=int, default=64, metavar='N',\n                    help='input batch size for training (default: 64)')\nparser.add_argument('--test-batch-size', type=int, default=1000, metavar='N',\n                    help='input batch size for testing (default: 1000)')\nparser.add_argument('--epochs', type=int, default=10, metavar='N',\n                    help='number of epochs to train (default: 10)')\nparser.add_argument('--lr', type=float, default=0.01, metavar='LR',\n                    help='learning rate (default: 0.01)')\nparser.add_argument('--momentum', type=float, default=0.5, metavar='M',\n                    help='SGD momentum (default: 0.5)')\nparser.add_argument('--no-cuda', action='store_true', default=False,\n                    help='disables CUDA training')\nparser.add_argument('--seed', type=int, default=1, metavar='S',\n                    help='random seed (default: 1)')\nparser.add_argument('--log-interval', type=int, default=10, metavar='N',\n                    help='how many batches to wait before logging training status')\nparser.add_argument('--save-model', action='store_true', default=False,\n                    help='For Saving the current Model')\nparser.add_argument('--norm-flag', type=bool, default=False,\n                    help='Triggering the Layer Normalization flag for attention scores')\nparser.add_argument('--gamma', type=float, default=None,\n                    help='Controlling the sparisty of gfusedmax/sparsemax, the smaller, the more sparse')\nparser.add_argument('--lam', type=float, default=1.0,\n                    help='Lambda: Controlling the smoothness of gfusedmax, the larger, the smoother')\nparser.add_argument('--max-type', type=str, default='softmax',choices=['softmax','sparsemax','gfusedmax'],\n                    help='mapping function in attention')\nparser.add_argument('--optim-type', type=str, default='SGD',choices=['SGD','Adam'],\n                    help='mapping function in attention')\nparser.add_argument('--head-cnt', type=int, default=2, metavar='S', choices=[1,2,4,5,10],\n                    help='Number of heads for attention (default: 1)')\n\nargs = parser.parse_args()\n\nhyperparameter_choices = {\n    'lr':list(10**np.arange(-4,-1,0.5)),\n    'norm_flag': [True,False],\n    'gamma':list(10**np.arange(-1,3,0.5))+[None,],\n    'lam':list(10**np.arange(-2,2,0.5)),\n    'max_type':['softmax','sparsemax','gfusedmax'],\n    \n    'optim_type':['SGD','Adam'],\n    'head_cnt':[1,2,4,5,10,20]\n}\n\nparam_num = 25\nrecord = np.zeros([param_num,len(hyperparameter_choices)+1])\nrecord_name = 'record3_multi_%s.csv'%time.strftime('%Y-%m-%d_%H-%M-%S',time.localtime())\nfor n in range(param_num):\n    for param_index,(k,v) in enumerate(hyperparameter_choices.items()):\n        print(param_index,k)\n        value_index = np.random.choice(len(v))\n        if isinstance(v[value_index],str) or isinstance(v[value_index],bool) or v[value_index] is None:\n            record[n,param_index] = value_index\n        else:\n            record[n,param_index] = v[value_index]\n        setattr(args,k,v[value_index])\n    record[n,-1] = main(args)\n    np.savetxt(record_name, record, delimiter=',')\n\n\n\n",
        "summary": "This Python script is designed to perform hyperparameter tuning for a machine learning model using the MNIST dataset. Here's a summary of its functionality:\n\n1. **Argument Parsing**: The script uses `argparse` to define and parse command-line arguments that control various aspects of the training process, such as batch size, number of epochs, learning rate, etc.\n\n2. **Hyperparameter Choices**: A dictionary named `hyperparameter_choices` is defined, containing lists of possible values for each hyperparameter. These include learning rates, normalization flags, sparsity controls, optimization types, and more.\n\n3. **Record Initialization**: An array `record` is initialized to store the results of different hyperparameter combinations along with their corresponding performance metrics.\n\n4. **Hyperparameter Sampling**: The script iterates over a specified number of trials (`param_num`). For each trial:\n   - It randomly selects a value for each hyperparameter from its respective list.\n   - These values are stored in the `record` array.\n   - The selected hyperparameters are applied to the `args` object, which is used to configure the model and training process.\n\n5. **Model Training**: For each set of hyperparameters, the script calls the `main` function from `my_multi_main3.py`, passing the configured `args` object. This function likely handles the actual training of the model using the specified hyperparameters.\n\n6. **Performance Recording**: The performance metric (likely accuracy or loss) returned by the `main` function is recorded in the `record` array along with the corresponding hyperparameter values.\n\n7. **Saving Results**: After all trials are completed, the script saves the entire `record` array to a CSV file named according to the current date and time. This allows for later analysis of which hyperparameter combinations performed best.\n\nOverall, this script automates the process of exploring different sets of hyperparameters to find the optimal configuration for training a machine learning model on the MNIST dataset."
    },
    {
        "code": "from __future__ import print_function, absolute_import\n\nimport h5py\n\nfrom spiker import log\n\nlogger = log.get_logger(\"data-hdf5\", log.DEBUG)\n\n\ndef init_hdf5(file_path, mode=\"w\", cam_type=\"davis\"):\n    \n    if mode == \"w\":\n        dataset = h5py.File(file_path, mode=mode)\n        dataset.create_group(\"dvs\")\n        dataset.create_group(\"extra\")\n        if cam_type == \"davis\":\n            dataset.create_group(\"aps\")\n            dataset.create_group(\"imu\")\n    elif mode == \"r\":\n        dataset = h5py.File(file_path, mode=mode)\n\n    return dataset\n",
        "summary": "This Python code defines a function `init_hdf5` that initializes an HDF5 file for storing data. The function takes three parameters: `file_path`, `mode`, and `cam_type`. \n\n- `file_path`: The path to the HDF5 file.\n- `mode`: The mode in which the file is opened, either \"w\" (write mode) or \"r\" (read mode).\n- `cam_type`: A string indicating the type of camera, defaulting to \"davis\".\n\nThe function uses the `h5py` library to handle HDF5 files. It also imports a logger from the `spiker.log` module.\n\nHere's what happens in the function:\n\n1. If the mode is \"w\" (write mode):\n   - The function opens an HDF5 file at the specified path.\n   - It creates three groups: \"dvs\", \"extra\", and \"aps\" if the camera type is \"davis\".\n   - It also creates another group called \"imu\".\n\n2. If the mode is \"r\" (read mode):\n   - The function opens an HDF5 file at the specified path in read mode.\n\nThe function returns the dataset object, which can be used to interact with the HDF5 file.\n\nThis setup is typically used for storing data from a camera system, where different types of data (like DVS events, extra information, and sensor data) are organized into separate groups within the HDF5 file."
    },
    {
        "code": "import flatbuffers\n\nclass FloatingPoint(object):\n    __slots__ = ['_tab']\n\n    @classmethod\n    def GetRootAsFloatingPoint(cls, buf, offset):\n        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)\n        x = FloatingPoint()\n        x.Init(buf, n + offset)\n        return x\n\n    \n    def Init(self, buf, pos):\n        self._tab = flatbuffers.table.Table(buf, pos)\n\n    \n    def Precision(self):\n        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))\n        if o != 0:\n            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)\n        return 0\n\ndef FloatingPointStart(builder): builder.StartObject(1)\ndef FloatingPointAddPrecision(builder, precision): builder.PrependInt16Slot(0, precision, 0)\ndef FloatingPointEnd(builder): return builder.EndObject()\n",
        "summary": "This Python code defines a class `FloatingPoint` that represents a floating-point number with a specific precision. It uses the FlatBuffers library to serialize and deserialize the data efficiently.\n\nHere's a breakdown of the key components:\n\n1. **Class Definition**:\n   - The `FloatingPoint` class has a single attribute `_tab`, which is used to store the table data from FlatBuffers.\n\n2. **Class Methods**:\n   - `GetRootAsFloatingPoint`: This method takes a buffer and an offset, decodes the buffer into a `FloatingPoint` object, and returns it.\n   - `Init`: This method initializes the `_tab` attribute with the provided buffer and position.\n\n3. **Attribute Accessors**:\n   - `Precision`: This method retrieves the precision of the floating-point number from the table. If the offset is not zero, it reads the int16 value at that offset; otherwise, it returns 0.\n\n4. **FlatBuffers Builder Methods**:\n   - `FloatingPointStart`, `FloatingPointAddPrecision`, and `FloatingPointEnd`: These methods are used to construct a `FloatingPoint` object using the FlatBuffers builder API.\n     - `FloatingPointStart`: Starts building a new `FloatingPoint` object.\n     - `FloatingPointAddPrecision`: Adds a precision value to the `FloatingPoint` object being built.\n     - `FloatingPointEnd`: Completes the construction of the `FloatingPoint` object and returns its offset.\n\nThis class is useful for handling floating-point numbers with specific precision in applications that require efficient serialization and deserialization, such as network protocols or data storage systems."
    }
]